# 03 텐서 조작하기

## 04 뷰(View) - 원소의 수를 유지하면서 텐서의 크기 변경 (매우 중요)

파이토치 텐서의 뷰(View)는 넘파이에서의 리쉐이프(Reshape)와 같은 역할을 함

Reshape라는 이름에서 알 수 있듯이, 텐서의 크기(Shape)를 변경해주는 역할을 함

실습을 위해 우선 임의로 다음과 같이 3차원 텐서를 만듬

```
t = np.array([[[0, 1, 2],
               [3, 4, 5]],
              [[6, 7, 8],
               [9, 10, 11]]])
ft = torch.FloatTensor(t)
```
ft라는 이름의 3차원 텐서를 만듬

크기(Shape)를 확인해보자
```
print(ft.shape)
```
```
torch.Size([2, 2, 3])
```

### 4-1) 3차원 텐서에서 2차원 텐서로 변경

이제 ft 텐서를 view를 사용하여 크기(shape)를 2차원 텐서로 변경해보자
```
print(ft.view([-1, 3]))
print(ft.view([-1, 3]).shape)
```
```
tensor([[ 0.,  1.,  2.],
        [ 3.,  4.,  5.],
        [ 6.,  7.,  8.],
        [ 9., 10., 11.]])
torch.Size([4, 3])
```
view([-1, 3])이 가지는 의미는 이와 같음

-1은 첫번째 차원은 사용자가 잘 모르겠으니 파이토치에 맡기겠다는 의미이고, 3은 두번째 차원의 길이는 3을 가지도록 하라는 의미

다시 말해 현재 3차원 텐서를 2차원 텐서로 변경하되 (?,3)의 크기로 변경하라는 의미

결과적으로 (4,3)의 크기를 가지는 텐서를 얻음

내부적으로 크기 변환은 다음과 같이 이뤄짐

(2, 2, 3) -> (2x2, 3) -> (4, 3)

규칙을 정리해보자

- view는 기본적으로 변경 전과 변경 후의 텐서 안의 원소의 개수가 유지되어야 함
- 파이토치의 view는 사이즈가 -1로 설정되면 다른 차원으로부터 해당 값을 유추함

변경 전 텐서의 원소 수는 (2 x 2 x 3) = 12개였음

그리고 변경 후 텐서의 원소의 개수 또한 (4 x 3) = 12개

### 4-2) 3차원 텐서의 크기 변경

이번에는 3차원 텐서에서 3차원 텐서로 차원은 유지하되, 크기(shape)를 바꾸는 작업을 해보자

view로 텐서의 크기를 변경하더라도 원소의 수는 유지되어야 한다고 언급한 바 있음

그렇다면 (2 x 2 x 3)텐서를 (? x 1 x 3) 텐서로 변경하라고 하면 ?는 몇차원일까 => 4

실습으로 확인해보자

```
print(ft.view([-1, 1, 3]))
print(ft.view([-1, 1, 3]).shape)
```

## 5) 스퀴즈(Squeeze) - 1인 차원을 제거함

스퀴즈는 차원이 1인 경우에는 해당 차원을 제거함

실습을 위해 임의로 (3 x 1)의 크기를 가지는 2차원 텐서를 만든다

```
ft = torch.FloatTensor([[0], [1], [2]])
print(ft)
print(ft.shape)
```
```
tensor([[0.],
        [1.],
        [2.]])
torch.Size([3, 1])
```

해당 텐서는 (3 x 1)의 크기를 가진다

두 번째 차원이 1이므로 squeeze를 사용하면 (3,)의 크기를 가지는 텐서로 변경된다

```
print(ft.squeeze())
print(ft.squeeze().shape)
```
```
tensor([0., 1., 2.])
torch.Size([3])
```
위의 결과는 1이었던 두번째 차원이 제거되면서 (3,)의 크기를 가지는 텐서로 변경되어 1차원 벡터가 된 것을 보여줌

## 6) 언스퀴즈(Unsqueeze) - 특정 위치에 1인 차원을 추가한다

언스퀴즈는 스퀴즈와 정반대

특정 위치에 1인 차원을 추가할 수 있음

실습을 위해 임의로 (3,)의 크기를 가지는 1인 차원 텐서를 만들어보자
```
ft = torch.Tensor([0, 1, 2])
print(ft.shape)
```
```
torch.Size([3])
```
현재는 차원이 1개인 1차원 벡터

여기에 첫번째 차원에 1인 차원을 추가해보자

첫번째 차원의 인덱스를 의미하는 숫자 0을 인자로 넣으면 첫번째 차원이 1인 차원이 추가

```
print(ft.unsqueeze(0))
print(ft.unsqueeze(0).shape)
```
```
tensor([[0., 1., 2.]])
torch.Size([1, 3])
```
위의 결과는 (3,)의 크기를 가졌던 1차원 벡터가 (1,3)의 2차원 텐서로 변경된 것을 보여줌

방금 한 연산을 앞서 배운 view로도 구현 가능함

2차원으로 바꾸고 싶으면서 첫번째 차원을 1이기를 원한다면 view에서 (1, -1)을 인자로 사용하면 됨

```
print(ft.view(1, -1))
print(ft.view(1, -1).shape)
```
위의 결과는 unsqueeze와 view가 동일한 결과를 만든 것을 보여줌

이번에는 unsqueeze의 인자로 1을 넣어보자

인덱스는 0부터 시작하므로 이는 두번째 차원에 1을 추가하겠다는것을 의미

인덱스는 0부터 시작하므로 이는 두번째 차원에 1을 추가하겠다는 것을 의미

현재 크기는 (3,)이었으므로 두번째 차원에 1인 차원을 (3,1)의 크기를 가지게 됨

실습을 진행해보자

```
print(ft.unsqueeze(1))
print(ft.unsqueeze(1).shape)
```

이번에는 unsqueeze의 인자로 -1은 인덱스 상으로 마지막 차원을 의미한다

현재 크기는 (3,)이었으므로 마지막 차원에 1인 차원을 추가하면 (3,1)의 크기를 가지게 됨

다시 말해 현재 텐서의 경우에는 1을 넣은 경우와 -1을 넣은 경우가 동일함

```
print(ft.unsqueeze(-1))
print(ft.unsqueeze(-1).shape)
```
```
tensor([[0.],
        [1.],
        [2.]])
torch.Size([3, 1])
```
맨 뒤에 1인 차원이 추가되면서 1차원 벡터가 (3, 1)의 크기를 가지는 2차원 텐서로 변경됨

## 7) 타입 캐스팅(Type Casting)
